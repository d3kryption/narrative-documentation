"use strict";(self.webpackChunknarrative_docs=self.webpackChunknarrative_docs||[]).push([[2724],{21556:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>s,contentTitle:()=>i,default:()=>c,frontMatter:()=>o,metadata:()=>d,toc:()=>l});var a=n(74848),r=n(28453);const o={sidebar_label:"2.0.0 Code Changes"},i="2.0.0 Code Changes",d={id:"inventory/changelog/version-2.0.0",title:"2.0.0 Code Changes",description:"NarrativeEquipment.Build.cs",source:"@site/docs/inventory/changelog/version-2.0.0.md",sourceDirName:"inventory/changelog",slug:"/inventory/changelog/version-2.0.0",permalink:"/narrative-documentation/inventory/changelog/version-2.0.0",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{sidebar_label:"2.0.0 Code Changes"},sidebar:"tutorialSidebar",previous:{title:"Changelog",permalink:"/narrative-documentation/inventory/changelog/"},next:{title:"Items",permalink:"/narrative-documentation/inventory/items/"}},s={},l=[{value:"NarrativeEquipment.Build.cs",id:"narrativeequipmentbuildcs",level:3},{value:"InventoryComponent.cpp",id:"inventorycomponentcpp",level:3},{value:"InventoryFunctionLibrary.cpp",id:"inventoryfunctionlibrarycpp",level:3},{value:"NarrativeItem.cpp",id:"narrativeitemcpp",level:3},{value:"VendorInventoryComponent.cpp",id:"vendorinventorycomponentcpp",level:3},{value:"VendorInventoryComponent.h",id:"vendorinventorycomponenth",level:3},{value:"InventoryComponent.h",id:"inventorycomponenth",level:3},{value:"InventoryComponent.h",id:"inventorycomponenth-1",level:3},{value:"NarrativeItem.h",id:"narrativeitemh",level:3},{value:"NarrativeInventory.Build.cs",id:"narrativeinventorybuildcs",level:3},{value:"NarrativeInventoryEditorModule.cpp",id:"narrativeinventoryeditormodulecpp",level:3},{value:"NarrativeInventoryEditorModule.h",id:"narrativeinventoryeditormoduleh",level:3}];function m(t){const e={code:"code",h1:"h1",h3:"h3",header:"header",p:"p",pre:"pre",...(0,r.R)(),...t.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"200-code-changes",children:"2.0.0 Code Changes"})}),"\n",(0,a.jsx)(e.h3,{id:"narrativeequipmentbuildcs",children:"NarrativeEquipment.Build.cs"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-cpp",metastring:'title="NarrativeEquipment/NarrativeEquipment.Build.cs" showLineNumbers',children:'PublicDependencyModuleNames.AddRange(\n    new string[]\n    {\n       "Core",\n       // added-start\n       "NarrativeInventory",\n       "GameplayTags"\n       // added-end\n       // ... add other public dependencies that you statically link with here ...\n   }\n);\n'})}),"\n",(0,a.jsx)(e.h3,{id:"inventorycomponentcpp",children:"InventoryComponent.cpp"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-cpp",metastring:'title="NarrativeInventory/Private/InventoryComponent.cpp" showLineNumbers',children:'UNarrativeInventoryComponent::UNarrativeInventoryComponent(const FObjectInitializer& ObjectInitializer) : Super(ObjectInitializer)\n{\n\tSetIsReplicatedByDefault(true);\n\n\tWeightCapacity = 100.f;\n\tCapacity = 50;\n\n   // added-start\n\tBuyItemPct = 0.5f;\n\tSellItemPct = 2.f;\n\n\tbGaveDefaultItems = false; \n   // added-end\n}\n\n...\n\nbool UNarrativeInventoryComponent::UseItem(class UNarrativeItem* Item)\n{\n   // added-start\n\tif (!IsValid(Item))\n\t{\n\t\treturn false;\n\t}\n   // added-end\n\n\tif (GetOwnerRole() < ROLE_Authority)\n\t{\n\t\tServerUseItem(Item);\n\t}\n}\n\n...\n\n// added-start\nvoid UNarrativeInventoryComponent::TryAddFromLootTable(FLootTableRoll LootTable, TArray<FItemAddResult>& OutItemAddResults)\n{\n\tif (LootTable.CanRoll())\n\t{\n\t\tconst TArray<FName> AllRows = LootTable.TableToRoll->GetRowNames();\n\n\t\tfor (int32 i = 0; i < LootTable.NumRolls; ++i)\n\t\t{\n\t\t\tif (FMath::FRand() <= LootTable.Chance)\n\t\t\t{\n\t\t\t\tconst FName RandomRowName = AllRows[FMath::RandRange(0, AllRows.Num() - 1)];\n\t\t\t\tconst FString ContextString = "LootRoll";\n\n\t\t\t\t//Grab a row from the loot table, and if it passes, grant the item\n\t\t\t\tif (FLootTableRow* Row = LootTable.TableToRoll->FindRow<FLootTableRow>(RandomRowName, ContextString))\n\t\t\t\t{\n\t\t\t\t\tif (FMath::FRand() <= Row->Chance)\n\t\t\t\t\t{\n\n\t\t\t\t\t\t//Grant the items and item collections \n\t\t\t\t\t\tfor (FItemWithQuantity& ItemToGive : Row->ItemsToGrant)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tOutItemAddResults.Add(TryAddItemFromClass(ItemToGive.Item.LoadSynchronous(), ItemToGive.Quantity));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (auto& Collection : Row->ItemCollectionsToGrant)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (IsValid(Collection))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfor (auto& Item : Collection->Items)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (!Item.Item.IsNull() && Item.Quantity > 0)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tOutItemAddResults.Add(TryAddItemFromClass(Item.Item.LoadSynchronous(), Item.Quantity));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (auto& Subtable : Row->SubTablesToRoll)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//Make sure the subtable we\'re about to roll isn\'t the same table we\'re already rolling, as that would cause an infinite loop \n\t\t\t\t\t\t\tif (Subtable.TableToRoll != LootTable.TableToRoll)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tTryAddFromLootTable(Subtable, OutItemAddResults);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid UNarrativeInventoryComponent::SetInventoryFriendlyName(const FText& Name)\n{\n\tInventoryFriendlyName = Name;\n}\n\nvoid UNarrativeInventoryComponent::SetIsVendor(const bool bNewIsVendor)\n{\n\tbIsVendor = bNewIsVendor;\n}\n\nvoid UNarrativeInventoryComponent::GiveDefaultItems()\n{\n\tif (!bGaveDefaultItems && GetOwnerRole() >= ROLE_Authority)\n\t{\n\t\tTArray<FItemAddResult> Results;\n\n\t\t/**TODO. This will cause a pretty big hitch because we\'re using LoadSyncronous on the items. We instead are going to want \n\t\tto modify TryAddFromLootTable to instead async load all the item soft refs and callback when they are ready to be added. */\n\t\tfor (auto& DefaultItemTable : DefaultItemTables)\n\t\t{\n\t\t\tTryAddFromLootTable(DefaultItemTable, Results);\n\t\t}\n\n\t\t//This is marked SaveGame, ensuring inventories are granted their items only once ever, even across multiple sessions. \n\t\tbGaveDefaultItems = true;\n\t}\n}\n\nint32 UNarrativeInventoryComponent::GetBuyPrice_Implementation(TSubclassOf<class UNarrativeItem> Item, int32 Quantity /*= 1*/) const\n{\n\tif (IsValid(Item))\n\t{\n\t\tif (const UNarrativeItem* ItemCDO = GetDefault<UNarrativeItem>(Item))\n\t\t{\n\t\t\treturn FMath::CeilToInt((ItemCDO->BaseValue * BuyItemPct) * Quantity);\n\t\t}\n\t}\n\treturn 0;\n}\n\nint32 UNarrativeInventoryComponent::GetSellPrice_Implementation(TSubclassOf<class UNarrativeItem> Item, int32 Quantity /*= 1*/) const\n{\n\tif (IsValid(Item))\n\t{\n\t\tif (const UNarrativeItem* ItemCDO = GetDefault<UNarrativeItem>(Item))\n\t\t{\n\t\t\treturn FMath::CeilToInt((ItemCDO->BaseValue * SellItemPct) * Quantity);\n\t\t}\n\t}\n\n\treturn INT_MAX;\n}\n// added-end\n\n...\n\n// removed-start\nFItemAddResult UNarrativeInventoryComponent::TryAddItemFromClass(TSubclassOf<class UNarrativeItem> ItemClass, const int32 Quantity /*=1*/)\n// removed-end\n// added-start\nFItemAddResult UNarrativeInventoryComponent::TryAddItemFromClass(TSubclassOf<class UNarrativeItem> ItemClass, const int32 Quantity /*=1*/, const bool bCheckAutoUse/*=false*/)\n// added-end\n\n...\n\nif (AddResult.AmountGiven > 0)\n{\n    OnItemAdded.Broadcast(AddResult);\n}\n\n// added-start\nif (bCheckAutoUse)\n{\n    for (auto& Stack : AddResult.Stacks)\n    {\n        if (Stack->ShouldUseOnAdd())\n        {\n            UseItem(Stack);\n        }\n    }\n}\n// added-end\n\n...\n\n// removed-start\nbool UNarrativeInventoryComponent::HasItem(TSubclassOf <class UNarrativeItem> ItemClass, const int32 Quantity /*= 1*/, const bool bCheckVisibility/*= false*/) const\n{\n\tif (IsValid(ItemClass))\n\t{\n\t\tif (UNarrativeItem* ItemCDO = ItemClass->GetDefaultObject<UNarrativeItem>())\n\t\t{\n\t\t\tif (ItemCDO->bStackable)\n\t\t\t{\n\t\t\t\t//if the item is stackable we can just check the stack quantity\n\t\t\t\tif (UNarrativeItem* ItemToFind = FindItemByClass(ItemClass))\n\t\t\t\t{\n\t\t\t\t\tif (!bCheckVisibility || ItemToFind->ShouldShowInInventory())\n\t\t\t\t\t{\n\t\t\t\t\t\treturn ItemToFind->GetQuantity() >= Quantity;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}//For non stackable items get all of them and check quantity\t\n\t\t\telse return FindItemsByClass(ItemClass, bCheckVisibility).Num() >= Quantity;\n\t\t}\n\t}\n\n\treturn false;\n}\n// removed-end\n\n// added-start\nbool UNarrativeInventoryComponent::HasItem(TSoftClassPtr<class UNarrativeItem> ItemClass, const int32 Quantity /*= 1*/, const bool bCheckVisibility/*= false*/) const\n{\n\tif (!ItemClass.IsNull())\n\t{\t\n\t\t//Todo re-write this, it needs to iterate the inventory and find all items with quantity \n\t\tif (UNarrativeItem* ItemToFind = FindItemByClass(ItemClass))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn false;\n}\n// added-end\n\n...\n\n// removed-start\nbool UNarrativeInventoryComponent::AllowLootItem(class UNarrativeInventoryComponent* Taker, TSubclassOf <class UNarrativeItem> ItemClass, const int32 Quantity, FText& ErrorText)  const\n// removed-end\n// added-start\nbool UNarrativeInventoryComponent::AllowLootItem(class UNarrativeInventoryComponent* Taker, TSubclassOf<class UNarrativeItem> ItemClass, const int32 Quantity, FText& ErrorText)  const\n// added-end\n\n...\n\n// removed-start\nconst bool bShopHasItem = HasItem(ItemClass, Quantity);\n// removed-end\n// added-start\nconst bool bShopHasItem = HasItem(TSoftClassPtr<UNarrativeItem>(ItemClass), Quantity);\n// added-end\n\n...\n\n// removed-start\nreturn bTakerHasSpace && bShopHasItem;\n// removed-end\n// added-start\nconst bool bWeHaveCurrency = !bIsVendor || GetCurrency() >= GetBuyPrice(ItemClass, Quantity);\n\nif (!bWeHaveCurrency)\n{\n    ErrorText = LOCTEXT("AllowStoreItem_NotEnoughMoney", "The shop doesn\'t have enough money to complete the trade.");\n}\n\nreturn bWeHaveSpace && bStorerHasItem && bWeHaveCurrency;\n// added-end\n\n...\n\n// removed-start\nif (UNarrativeItem* Item = FindItemByClass(ItemClass))\n// removed-end\n// added-start\nif (UNarrativeItem* Item = FindItemByClass(TSoftClassPtr<UNarrativeItem>(ItemClass)))\n// added-end\n\n...\n\n// added-start\n    if (bIsVendor && Taker)\n    {\n        const int32 TransactionPrice = GetSellPrice(ItemClass, AddResult.AmountGiven);\n\n        //We sold an item, need to remove cash from taker and store in our inventory \n        Taker->AddCurrency(-TransactionPrice);\n        AddCurrency(TransactionPrice);\n    }\n// added-end\n}\n\nreturn AddResult;\n\n...\n\nif (Storer)\n{\n    //Store the item in our inventory\n    // removed-start\n    const FItemAddResult AddResult = TryAddItemFromClass(ItemClass);\n    // removed-end\n    // added-start\n    const FItemAddResult AddResult = TryAddItemFromClass(ItemClass, Quantity);\n    // added-end\n\n...\n\nif (AddResult.AmountGiven > 0)\n{\n    // removed-start\n    if (UNarrativeItem* Item = Storer->FindItemByClass(ItemClass))\n    // removed-end\n    // added-start\n    if (UNarrativeItem* Item = Storer->FindItemByClass(TSoftClassPtr<UNarrativeItem>(ItemClass)))\n    // added-end\n    {\n        //However much of the item we managed to store, remove from the storers inventory\n\n...\n\n// added-start\n    if (bIsVendor && Storer)\n    {\n        const int32 TransactionPrice = GetBuyPrice(ItemClass, AddResult.AmountGiven);\n\n        //We sold an item, need to remove cash from taker and store in our inventory \n        Storer->AddCurrency(TransactionPrice);\n        AddCurrency(-TransactionPrice);\n    }\n    // added-end\n}\n\nreturn AddResult;\n\n...\n\n// removed-start\nUNarrativeItem* UNarrativeInventoryComponent::FindItemByClass(TSubclassOf<class UNarrativeItem> ItemClass, const bool bCheckVisibility/*= false*/) const\n// removed-end\n// added-start\nUNarrativeItem* UNarrativeInventoryComponent::FindItemByClass(TSoftClassPtr<class UNarrativeItem> ItemClass, const bool bCheckVisibility/*= false*/) const\n// added-end\n\n...\n\nTArray<UNarrativeItem*> UNarrativeInventoryComponent::FindItemsByClass(TSubclassOf<class UNarrativeItem> ItemClass, const bool bCheckVisibility/*= false*/) const\n// added-start\nTArray<UNarrativeItem*> UNarrativeInventoryComponent::FindItemsOfClass(TSubclassOf<class UNarrativeItem> ItemClass, const bool bCheckVisibility/*= false*/) const\n// added-end\n\n...\n\n//Figure out how many of a given item we can add \nif (const UNarrativeItem* ItemCDO = GetDefault<UNarrativeItem>(ItemClass))\n{\n    // added-start\n    if (Items.Num() >= GetCapacity())\n    {\n        NoSpaceReason = LOCTEXT("NoSpaceReason_CapacitySpace", "You don\'t have any inventory slots left for this item.");\n        return 0;\n    }\n// added-end\n\n...\n\n// removed-start\nif (UNarrativeItem* ExistingItem = FindItemByClass(ItemClass))\n// removed-end\n// added-start\nif (UNarrativeItem* ExistingItem = FindItemByClass(TSoftClassPtr<UNarrativeItem>(ItemClass)))\n// added-end\n\n...\n\nInventorySave->SavedCurrency = Currency;\n\n// added-start\n// Clear previously saved items to ensure we\'re saving the current state.\nInventorySave->SavedItems.Empty();\n// added-end\n\nfor (auto& Item : Items)\n\n...\n\n// removed-start\nreturn true;\n// removed-end\n// added-start\nreturn false;\n// added-end\n\n...\n\nbool UNarrativeInventoryComponent::Load(const FString& SaveName /*= "NarrativeInventorySaveData"*/, const int32 Slot /*= 0*/)\n{\n    // removed-start\n    if (!UGameplayStatics::DoesSaveGameExist(SaveName, 0))\n    // removed-end\n    // added-start\n    if (!UGameplayStatics::DoesSaveGameExist(SaveName, Slot))\n    // added-end\n    {\n        return false;\n    }\n\n    // added-start\n\t//Deactivate any active items we currently have \n\tfor (auto& Item : Items)\n\t{\n\t\tif (Item->bActive)\n\t\t{\n\t\t\tItem->SetActive(false, true);\n\t\t}\n\t}\n    // added-end\n\n...\n\n// removed-start\ncheck(AddResult.CreatedStacks.Num() && AddResult.CreatedStacks.IsValidIndex(0));\n// removed-end\n// added-start\ncheck(AddResult.Stacks.Num() && AddResult.Stacks.IsValidIndex(0));\n// added-end\n\n...\n\n// removed-start\nif (UNarrativeItem* AddedItem = AddResult.CreatedStacks[0])\n// removed-end\n// added-start\nif (UNarrativeItem* AddedItem = AddResult.Stacks[0])\n// added-end\n\n...\n\nvoid UNarrativeInventoryComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tOwnerPC = GetOwningController();\n    // removed-start\n\tfor (auto& Item : DefaultItems)\n\t{\n\t\tif (Item)\n\t\t{\n\t\t\tTryAddItemFromClass(Item->GetClass(), Item->GetQuantity());\n\t\t}\n\t}\n\n\tDefaultItems.Empty();\n\t// removed-end\n}\n\n...\n\n// removed-start\nOnEndLooting.Broadcast();\n// removed-end\n// added-start\nOnEndLooting.Broadcast(LootSource);\n// added-end\n\n...\n\n//Top up any existing stacks with the add amount, stopping if we ran out of items to give \n// removed-start\nfor (auto& Stack : FindItemsByClass(ItemClass))\n// removed-end\n// added-start\nfor (auto& Stack : FindItemsOfClass(ItemClass))\n// added-end\n\n...\n\n//UE_LOG(LogTemp, Warning, TEXT("Adding %s adding %d to existing stack"), *ItemCDO->DisplayName.ToString(), AmountGiven);\nLeftToAdd -= AmountGiven;\n\n// added-start\nAddResult.Stacks.Add(Stack);\n// added-end\n\n...\n\nif (UNarrativeItem* NewItem = AddItem(ItemClass, MaxStackSize))\n{\n// removed-start\n    AddResult.CreatedStacks.Add(NewItem);\n// removed-end\n// added-start\n    AddResult.Stacks.Add(NewItem);\n// added-end\n}\n\n...\n\nif (UNarrativeItem* NewItem = AddItem(ItemClass, Remainder))\n{\n// removed-start\n    AddResult.CreatedStacks.Add(NewItem);\n// removed-end\n// added-start\n    AddResult.Stacks.Add(NewItem);\n// added-end\n}\n\n...\n\n        ServerRequestLootItem(ItemToLoot, Quantity);\n        return true;\n    }\n    \n    // removed-start\n    LootSource->PerformLootItem(this, ItemToLoot->GetClass(), Quantity);\n    // removed-end\n    // added-start\n    LootSource->PerformLootItem(this, ItemToLoot->GetClass(), Quantity);\n    // added-end\n    return true;\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"inventoryfunctionlibrarycpp",children:"InventoryFunctionLibrary.cpp"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-cpp",metastring:'title="NarrativeInventory/Private/InventoryFunctionLibrary.cpp" showLineNumbers',children:"\t//Try player state, then pawn, then controller \n    // removed-start\n\tif (APawn* OwningPawn = Cast<APawn>(Target))\n    // removed-end\n    // added-start\n\tif (const APawn* OwningPawn = Cast<APawn>(Target))\n    // added-end\n\t{\n\t    // removed-start\n\t\tif (OwningPawn->GetPlayerState())\n\t\t{\n\t\t\treturn OwningPawn->GetPlayerState()->FindComponentByClass<UNarrativeInventoryComponent>();\n\t\t}\n\t\t// removed-end\n\t\t// added-start\n                if (const APlayerState* PlayerState = OwningPawn->GetPlayerState<APlayerState>())\n\t\t{\n\t\t\tif (UNarrativeInventoryComponent* InventoryComp = PlayerState->FindComponentByClass<UNarrativeInventoryComponent>())\n\t\t\t{\n\t\t\t\treturn InventoryComp;\n\t\t\t}\n\t\t}\n\t\t// added-end\n\n        // removed-start\n\t\tif (OwningPawn->GetController())\n\t\t{\n\t\t\treturn OwningPawn->GetController()->FindComponentByClass<UNarrativeInventoryComponent>();\n\t\t}\n\t\t// removed-end\n\t\t// added-start\n                if (const AController* OwningController = OwningPawn->GetController())\n\t\t{\n\t\t\tif (UNarrativeInventoryComponent* InventoryComp = OwningController->FindComponentByClass<UNarrativeInventoryComponent>())\n\t\t\t{\n\t\t\t\treturn InventoryComp;\n\t\t\t}\n\t\t}\n\t\t// added-end\n\t}\n\n\t//Same for controller based target \n\t// removed-start\n\tif (APlayerController* OwningController = Cast<APlayerController>(Target))\n    // removed-end\n    // added-start\n\telse if (const APlayerController* OwningController = Cast<APlayerController>(Target))\n    // added-end\n\t{\n\t\tif (OwningController->GetPawn())\n\t\t{\n\t\t    // removed-start\n\t\t\tif (OwningController->GetPlayerState<APlayerState>())\n\t\t\t{\n\t\t\t\treturn OwningController->GetPlayerState<APlayerState>()->FindComponentByClass<UNarrativeInventoryComponent>();\n\t\t\t}\n            // removed-end\n            // added-start\n\t\t\tif (const APlayerState* PlayerState = OwningController->GetPlayerState<APlayerState>())\n\t\t\t{\n\t\t\t\tif (UNarrativeInventoryComponent* InventoryComp = PlayerState->FindComponentByClass<UNarrativeInventoryComponent>())\n\t\t\t\t{\n\t\t\t\t\treturn InventoryComp;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// added-end\n\n\t\t\treturn OwningController->GetPawn()->FindComponentByClass<UNarrativeInventoryComponent>();\n\t\t}\n\t}\n\n\treturn nullptr;\n}\n"})}),"\n",(0,a.jsx)(e.h3,{id:"narrativeitemcpp",children:"NarrativeItem.cpp"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-cpp",metastring:'title="NarrativeInventory/Private/NarrativeItem.cpp" showLineNumbers',children:'#define LOCTEXT_NAMESPACE "Item"\n\n// added-start\n#define ItemStat_DisplayName "DisplayName"\n#define ItemStat_Weight "Weight"\n#define ItemStat_Quantity "Quantity"\n#define ItemStat_RechargeDuration "RechargeDuration"\n#define ItemStat_StackWeight "StackWeight"\n#define ItemStat_MaxStackSize "MaxStackSize"\n#define ItemStat_BaseValue "BaseValue"\n// added-end\n\n...\n\n\t\tDisplayName = FText::FromString(NameString);\n\t}\n\n    // removed-start\n\tStats.Add("Weight");\n\tStats.Add("Quantity");\n    // removed-end\n    // added-start\n\tStats.Add(FNarrativeItemStat(LOCTEXT("WeightStatDisplayText", "Weight"), ItemStat_Weight));\n\tStats.Add(FNarrativeItemStat(LOCTEXT("QuantityStatDisplayText", "Quantity"), ItemStat_Quantity));\n    // added-end\n}\n\n...\n\n// removed-start\nvoid UNarrativeItem::SetActive(const bool bNewActive)\n{\n\tif (CanActivate() && bNewActive != bActive)\n\t{\n\t\tbActive = bNewActive;\n\t\tOnRep_bActive(!bActive);\n\t\tMarkDirtyForReplication();\n\t}\n}\n// removed-end\n// added-start\nvoid UNarrativeItem::SetActive(const bool bNewActive, const bool bForce)\n{\n\tif (bCanActivate)\n\t{\n\t\tif (bNewActive != bActive || bForce)\n\t\t{\n\t\t\tbActive = bNewActive;\n\t\t\tOnRep_bActive(!bActive);\n\t\t\tMarkDirtyForReplication();\n\t\t}\n\t}\n}\n// added-end\n\n...\n\n// added-start\nFText UNarrativeItem::GetRawDescription_Implementation()\n{\n\treturn Description;\n}\n\nbool UNarrativeItem::ShouldUseOnAdd_Implementation() const\n{\n\treturn false;\n}\n// added-end\n\n...\n\nbool UNarrativeItem::ShouldShowInInventory_Implementation() const\n{\n    // added-start\n\t//By default, don\'t show vendors equipped items in their store  \n\tif (OwningInventory && OwningInventory->bIsVendor)\n\t{\n\t\tif (bActive)\n\t\t{\n\t\t\treturn false; \n\t\t}\n\t}\n    // added-end\n\n\treturn true;\n}\n\n...\n\nFString UNarrativeItem::GetStringVariable_Implementation(const FString& VariableName)\n{\n\t//Overriable in BP in case you want to add more \n    // removed-start\n\tif (VariableName == "Display Name")\n    // removed-end\n    // added-start\n\tif (VariableName == ItemStat_DisplayName)\n    // added-end\n    \n...\n\n    // removed-start\n\telse if (VariableName == "Weight")\n    // removed-end\n    // added-start\n\telse if (VariableName == ItemStat_Weight)\n    // added-end\n    \n...\n\n    // removed-start\n\telse if (VariableName == "Recharge Duration")\n    // removed-end\n    // added-start\n\telse if (VariableName == ItemStat_RechargeDuration)\n    // added-end\n    \n...\n\n    // removed-start\n\telse if (VariableName == "Stack Weight")\n    // removed-end\n    // added-start\n\telse if (VariableName == ItemStat_StackWeight)\n    // added-end\n    \n...\n\n    // removed-start\n\telse if (VariableName == "Quantity")\n    // removed-end\n    // added-start\n\telse if (VariableName == ItemStat_Quantity)\n    // added-end\n    \n...\n\n    // removed-start\n\telse if (VariableName == "Max Stack Size")\n    // removed-end\n    // added-start\n\telse if (VariableName == ItemStat_MaxStackSize)\n    // added-end\n\t    \n...\n\n    // removed-start\n\telse if (VariableName == "BaseValue")\n    // removed-end\n    // added-start\n\telse if (VariableName == ItemStat_BaseValue)\n    // added-end\n    \n...\n\n\treturn FString();\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"vendorinventorycomponentcpp",children:"VendorInventoryComponent.cpp"}),"\n",(0,a.jsx)(e.p,{children:"This file can be deleted."}),"\n",(0,a.jsx)(e.h3,{id:"vendorinventorycomponenth",children:"VendorInventoryComponent.h"}),"\n",(0,a.jsx)(e.p,{children:"This file can be deleted."}),"\n",(0,a.jsx)(e.h3,{id:"inventorycomponenth",children:"InventoryComponent.h"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-cpp",metastring:'title="NarrativeInventory/public/InventoryComponent.h" showLineNumbers',children:'// removed-start\n#include "Components/ActorComponent.h"\n// added-start\n#include <Engine/DataTable.h>\n#include <Engine/DataAsset.h>\n// added-end\n\n...\n\n// removed-start\nTArray<class UNarrativeItem*> CreatedStacks = {};\n// removed-end\n// added-start\nTArray<class UNarrativeItem*> Stacks = {};\n// added-end\n\n...\n\n// removed-start\nAddedSomeResult.CreatedStacks = InItems;\n// removed-end\n// added-start\nAddedSomeResult.Stacks = InItems;\n// added-end\n\n...\n\n// removed-start\nAddAllResult.CreatedStacks = InItems;\n// removed-end\n// added-start\nAddAllResult.Stacks = InItems;\n// added-end\n\n...\n\n// removed-start\nDECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnEndLooting);\n// removed-end\n// added-start\nDECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnEndLooting, class UNarrativeInventoryComponent*, LootSource);\n// added-end\n\n...\n\n// added-start\n//Just a nice way of defining an item along with some amount of the item \nUSTRUCT(BlueprintType)\nstruct FItemWithQuantity\n{\n\tGENERATED_BODY()\n\npublic:\n\n\tFItemWithQuantity()\n\t{\n\t\tItem = nullptr;\n\t\tQuantity = 1;\n\t};\n\n\tUPROPERTY(BlueprintReadOnly, EditDefaultsOnly, Category = "Item")\n\tTSoftClassPtr<class UNarrativeItem> Item;\n\n\tUPROPERTY(BlueprintReadOnly, EditDefaultsOnly, Category = "Item")\n\tint32 Quantity;\n};\n\n/**\n * Data asset with a collection of items. Useful for grouping things together like armor sets, weapon sets, etc. \n */\nUCLASS()\nclass NARRATIVEINVENTORY_API UItemCollection : public UDataAsset\n{\n\tGENERATED_BODY()\n\t\npublic:\n\n\tUItemCollection()\n\t{\n\n\t};\n\n\t//The items to grant if this row is given to the inventory\n\tUPROPERTY(EditAnywhere, Category = "Loot Table Row")\n\tTArray<FItemWithQuantity> Items;\n\n};\n\n//Defines a roll of a loot table \nUSTRUCT(BlueprintType)\nstruct FLootTableRoll\n{\n\tGENERATED_BODY()\npublic:\n\n\tFLootTableRoll()\n\t{\n\t\tNumRolls = 1;\n\t\tChance = 1.f;\n\t}\n\n\n\t//The items to grant if this row is given to the inventory \n\tUPROPERTY(EditAnywhere, Category = "Loot Table Row", meta = (RequiredAssetDataTags = "RowStructure=/Script/NarrativeInventory.LootTableRow"))\n\tTObjectPtr<UDataTable> TableToRoll;\n\n\t//The number of times we should roll the table \n\tUPROPERTY(EditAnywhere, Category = "Loot Table Row", meta = (ClampMin = 0, ClampMax = 100))\n\tint32 NumRolls;\n\n\t//The chance of each roll succeeding \n\tUPROPERTY(EditAnywhere, Category = "Loot Table Row", meta = (ClampMin=0.0, ClampMax=1.0))\n\tfloat Chance;\n\n\tbool CanRoll() const\n\t{\n\t\treturn IsValid(TableToRoll) && NumRolls > 0 && Chance > 0.f;\n\t}\n\n};\n\n//Defines a row in a loot table\nUSTRUCT(BlueprintType)\nstruct FLootTableRow : public FTableRowBase\n{\n\tGENERATED_BODY()\npublic:\n\n\tFLootTableRow()\n\t{\n\t\tChance = 1.f;\n\t}\n\n\t//The items to grant if this row is given to the inventory\n\tUPROPERTY(EditAnywhere, Category = "Loot Table Row")\n\tTArray<FItemWithQuantity> ItemsToGrant;\n\n\t//Item collections to grant\n\tUPROPERTY(EditAnywhere, Category = "Loot Table Row")\n\tTArray<TObjectPtr<UItemCollection>> ItemCollectionsToGrant;\n\n\t//Subloot tables that this loot table will roll \n\tUPROPERTY(EditAnywhere, Category = "Loot Table Row")\n\tTArray<struct FLootTableRoll> SubTablesToRoll;\n\n\t//The chance this row will actually be given if selected \n\tUPROPERTY(EditAnywhere, Category = "Loot Table Row", meta = (ClampMin=0.0, ClampMax=1.0))\n\tfloat Chance;\n};\n\n// added-end\n\n...\n\n// added-start\n/**Add an item to our inventory using a loot table instead of an item class. Current loads the granted items syncrounously and may cause hitching depending on how heavy the item is. */\nUFUNCTION(BlueprintCallable, Category = "Inventory")\nvirtual void TryAddFromLootTable(FLootTableRoll LootTable, TArray<FItemAddResult>& OutItemAddResults);\n\t\nUFUNCTION(BlueprintCallable, Category = "Inventory")\nvoid SetInventoryFriendlyName(const FText& Name);\n\nUFUNCTION(BlueprintCallable, Category = "Inventory")\nvoid SetIsVendor(const bool bNewIsVendor);\n// added-end\n\n...\n\n// removed-start\nvirtual FItemAddResult TryAddItemFromClass(TSubclassOf<class UNarrativeItem> ItemClass, const int32 Quantity = 1);\n// removed-end\n// added-start\nvirtual FItemAddResult TryAddItemFromClass(TSubclassOf<class UNarrativeItem> ItemClass, const int32 Quantity = 1, const bool bCheckAutoUse=true);\n// added-end\n\t\n...\n\n// removed-start\nvirtual bool HasItem(TSubclassOf <class UNarrativeItem> ItemClass, const int32 Quantity = 1, const bool bCheckVisibility = false) const;\n// removed-end\n// added-start\nvirtual bool HasItem(TSoftClassPtr<class UNarrativeItem> ItemClass, const int32 Quantity = 1, const bool bCheckVisibility = false) const;\n// added-end\n\t\n...\n\n// removed-start\nvirtual bool AllowLootItem(class UNarrativeInventoryComponent* Taker, TSubclassOf <class UNarrativeItem> ItemClass, const int32 Quantity, FText& ErrorText) const;\n// removed-end\n// added-start\nvirtual bool AllowLootItem(class UNarrativeInventoryComponent* Taker, TSubclassOf<class UNarrativeItem> ItemClass, const int32 Quantity, FText& ErrorText) const;\n// added-end\n\t\n...\n\t\n// removed-start\nvirtual bool AllowStoreItem(class UNarrativeInventoryComponent* Storer, TSubclassOf <class UNarrativeItem> ItemClass, const int32 Quantity, FText& ErrorText) const;\n// removed-end\n// added-start\nvirtual bool AllowStoreItem(class UNarrativeInventoryComponent* Storer, TSubclassOf<class UNarrativeItem> ItemClass, const int32 Quantity, FText& ErrorText) const;\n// added-end\n\t\n...\n\n// removed-start\nUNarrativeItem* FindItemByClass(TSubclassOf<class UNarrativeItem> ItemClass, const bool bCheckVisibility = false) const;\n// removed-end\n// added-start\nUNarrativeItem* FindItemByClass(TSoftClassPtr<class UNarrativeItem> ItemClass, const bool bCheckVisibility = false) const;\n// added-end\n\t\n...\n\t\n// removed-start\nTArray<UNarrativeItem*> FindItemsByClass(TSubclassOf<class UNarrativeItem> ItemClass, const bool bCheckVisibility = false) const;\n// removed-end\n// added-start\nTArray<UNarrativeItem*> FindItemsOfClass(TSubclassOf<class UNarrativeItem> ItemClass, const bool bCheckVisibility = false) const;\n// added-end\n\n...\n\n// removed-start\n/**Items that should be put in our inventory on BeginPlay */\nUPROPERTY(EditDefaultsOnly, Instanced, Category = "Inventory")\nTArray<class UNarrativeItem*> DefaultItems;\n// removed-end\n// added-start\n/**Items that should be put in our inventory on BeginPlay. We savegame this as to only add the items once.  */\nUPROPERTY(EditDefaultsOnly, Category = "Inventory")\nTArray<FItemWithQuantity> DefaultItems;\n\n/** Loot table we\'ll use to generate this inventories items. */\nUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Inventory")\nTArray<FLootTableRoll> DefaultItemTables;\n\n/** Nice way to ensure we don\'t give default items multiple times.  */\nUPROPERTY(SaveGame, BlueprintReadOnly, Category = "Inventory")\nbool bGaveDefaultItems;\n\n/** If true, this inventory will be treated as a vendor, meaning taking/giving items will check you/the vendor has enough currency, and will \ngive you/the vendor the currency when the taking/giving occurs also. */\nUPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Inventory")\nbool bIsVendor;\n\n//The percentage of the items value we\'ll buy items for if we\'re a vendor. \nUPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Vendor Settings")\nfloat BuyItemPct;\n\n//The percentage of the items value we\'ll sell items for \nUPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Vendor Settings")\nfloat SellItemPct;\n// added-end\n\n...\n\n//Internal, non-BP exposed add item function. Don\'t call this directly, use TryAddItem(), or TryAddItemFromClass() instead.\nvirtual FItemAddResult TryAddItem_Internal(TSubclassOf<class UNarrativeItem> ItemClass, const int32 Quantity = 1);\n\n// added-start\npublic:\n\n\t/** Instead of calling this automatically on beginplay we let designers call this when they like.  */\n\tUFUNCTION(BlueprintCallable, Category = "Inventory")\n\tvirtual void GiveDefaultItems();\n\n\t/**Sets our loot source. Only the server can call this for obvious reasons! */\n\tUFUNCTION(BlueprintCallable, BlueprintAuthorityOnly, Category = "Inventory")\n\tvirtual void SetLootSource(class UNarrativeInventoryComponent* NewLootSource);\n\nprotected:\n// added-end\n\n...\n\n// removed-start\n/**Sets our loot source. Only the server can call this for obvious reasons! */\nUFUNCTION(BlueprintCallable, BlueprintAuthorityOnly, Category = "Inventory")\nvirtual void SetLootSource(class UNarrativeInventoryComponent* NewLootSource);\n// removed-end\n\n...\n\n// added-start\n/**\n* Return the price we\'ll buy the given item for\n*/\nUFUNCTION(BlueprintNativeEvent, BlueprintPure, Category = "Item")\nint32 GetBuyPrice(TSubclassOf<class UNarrativeItem> Item, int32 Quantity = 1) const;\nvirtual int32 GetBuyPrice_Implementation(TSubclassOf<class UNarrativeItem> Item, int32 Quantity = 1) const;\n\n/**\n* Return the price we\'ll sell the given item for\n*/\nUFUNCTION(BlueprintNativeEvent, BlueprintPure, Category = "Item")\nint32 GetSellPrice(TSubclassOf<class UNarrativeItem> Item, int32 Quantity = 1) const;\nvirtual int32 GetSellPrice_Implementation(TSubclassOf<class UNarrativeItem> Item, int32 Quantity = 1) const;\n// added-end\n\n'})}),"\n",(0,a.jsx)(e.h3,{id:"inventorycomponenth-1",children:"InventoryComponent.h"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-cpp",metastring:'title="NarrativeInventory/public/InventoryFunctionLibrary.h" showLineNumbers',children:"\tGENERATED_BODY()\n// added-start\npublic:\n// added-end\n\t/**\n\t* Find the inventory component from the supplied target object. \n\n"})}),"\n",(0,a.jsx)(e.h3,{id:"narrativeitemh",children:"NarrativeItem.h"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-cpp",metastring:'title="NarrativeInventory/public/NarrativeItem.h" showLineNumbers',children:'#include "InventoryComponent.h"\n// added-start\n#include <GameplayTagContainer.h>\n// added-end\n#include "NarrativeItem.generated.h"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnItemModified);\n\n// added-start\n//A stat that can be shown in the item preview window\nUSTRUCT(BlueprintType)\nstruct FNarrativeItemStat\n{\n\tGENERATED_BODY()\n\n\tFNarrativeItemStat(const FText& InStatDisplayName, const FString& InStringVariable) : StatDisplayName(InStatDisplayName), StringVariable(InStringVariable)\n\t{\n\n\t}\n\n\tFNarrativeItemStat()\n\t{\n\t\tStatDisplayName = NSLOCTEXT("NarrativeItemStat", "StatDisplayName", "Stat Display Name");\n\t\tStringVariable = FString();\n\t};\n\n\t//The stats display name.\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Item Stat")\n\tFText StatDisplayName;\n\n\t//The backing string variable for the stat - implemented using GetStringVariable function that can be overriden in Blueprints! \n\tUPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Item Stat")\n\tFString StringVariable;\n};\n// added-end\n\n...\n\n// added-start\n/**The use sound for the item*/\nUPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category = "Item")\nTObjectPtr<class USoundBase> UseSound;\n\n/**Any gameplay tags we wish to give this item*/\nUPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category = "Item")\nFGameplayTagContainer ItemTags;\n\n/**\n* Define whether the item should automatically use itself when added to our inventory.\n*/\nUFUNCTION(BlueprintNativeEvent, BlueprintPure, Category = "Item")\nbool ShouldUseOnAdd() const;\nvirtual bool ShouldUseOnAdd_Implementation() const;\n// added-end\n\t\n...\n\n/**Some items might need to be activatable. Check this box if you want the item to be able to activate. \nActivating will mean different things for different item types, for example clothing being activated would\n// removed-start\nmean it equips to the player. \n// removed-end\n// added-start\nmean it equips to the player - you define this using the Activate and Deactivate() functions. \n// added-end\n\n...\n\n// removed-start\nTArray<FString> Stats;\n// removed-end\n// added-start\nTArray<FNarrativeItemStat> Stats;\n// added-end\n\n...\n\n// removed-start\nvoid SetActive(const bool bNewActive);\n// removed-end\n// added-start\nvoid SetActive(const bool bNewActive, const bool bForce=false);\n// added-end\n\n...\n\n// removed-start\n/**Return the description with none of the string variables parsed*/\nUFUNCTION(BlueprintPure, Category = "Item")\nFORCEINLINE FText GetRawDescription() const {return Description;}\n// removed-end\n// added-start\n/**Return the description - allows BPs to override this in case you want automatically dynamically generated descriptions based on the items properties. */\nUFUNCTION(BlueprintNativeEvent, BlueprintPure, Category = "Item")\nFText GetRawDescription();\nvirtual FText GetRawDescription_Implementation();\n// added-end\n\n...\n\n// removed-start\n/**\n* Allows you to define whether or not the item can be activated\n*/\nUFUNCTION(BlueprintNativeEvent, BlueprintPure, Category = "Item")\nbool CanActivate() const;\nvirtual bool CanActivate_Implementation() const;\n// removed-end\n\n'})}),"\n",(0,a.jsx)(e.h3,{id:"narrativeinventorybuildcs",children:"NarrativeInventory.Build.cs"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-cpp",metastring:'title="NarrativeInventory/NarrativeInventory.Build.cs" showLineNumbers',children:'PublicDependencyModuleNames.AddRange(\n    new string[]\n    {\n        "UMG",\n       // added-start\n        "GameplayTags",\n        "CommonUI"\n       // added-end\n       // ... add other public dependencies that you statically link with here ...\n   }\n);\n'})}),"\n",(0,a.jsx)(e.h3,{id:"narrativeinventoryeditormodulecpp",children:"NarrativeInventoryEditorModule.cpp"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-cpp",metastring:'title="NarrativeInventory/Private/NarrativeInventoryEditorModule.cpp" showLineNumbers',children:'#include "AssetTypeActions_NarrativeItem.h"\n// added-start\n#include "AssetTypeActions_ItemCollection.h"\n// added-end\n\n...\n\nNarrativeItemTypeActions = NarrativeItemTypeAction;\n// added-start\nAssetToolsModule.RegisterAssetTypeActions(NarrativeItemTypeAction.ToSharedRef());\n\nTSharedPtr<FAssetTypeActions_ItemCollection> NarrativeItemCollectionTypeAction = MakeShareable(new FAssetTypeActions_ItemCollection(GameAssetCategory));\nNarrativeItemCollectionTypeActions = NarrativeItemCollectionTypeAction;\n// added-end\nAssetToolsModule.RegisterAssetTypeActions(NarrativeItemTypeAction.ToSharedRef());\n'})}),"\n",(0,a.jsx)(e.h3,{id:"narrativeinventoryeditormoduleh",children:"NarrativeInventoryEditorModule.h"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-cpp",metastring:'title="NarrativeInventory/Public/NarrativeInventoryEditorModule.h" showLineNumbers',children:"TSharedPtr<class FAssetTypeActions_Base> NarrativeItemTypeActions;\n// added-start\nTSharedPtr<class FAssetTypeActions_Base> NarrativeItemCollectionTypeActions;\n// added-end\n"})})]})}function c(t={}){const{wrapper:e}={...(0,r.R)(),...t.components};return e?(0,a.jsx)(e,{...t,children:(0,a.jsx)(m,{...t})}):m(t)}},28453:(t,e,n)=>{n.d(e,{R:()=>i,x:()=>d});var a=n(96540);const r={},o=a.createContext(r);function i(t){const e=a.useContext(o);return a.useMemo((function(){return"function"==typeof t?t(e):{...e,...t}}),[e,t])}function d(t){let e;return e=t.disableParentContext?"function"==typeof t.components?t.components(r):t.components||r:i(t.components),a.createElement(o.Provider,{value:e},t.children)}}}]);